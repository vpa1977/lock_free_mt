#include "feature_textures.h"

CFeature_Textures::CFeature_Textures() {
}

CFeature_Textures::~CFeature_Textures() {
}

void
CFeature_Textures::AddFragments( INVLink* in_pLinker ) {
	{
		HANDLE hFile = CreateFile("tex_passthru.nvo", GENERIC_READ, 0, NULL, OPEN_EXISTING, 0, NULL);
		assert( INVALID_HANDLE_VALUE != hFile );
		DWORD dwFileSize = GetFileSize(hFile, NULL);
		void* pFragments = (void*)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, dwFileSize);
		ReadFile(hFile, pFragments, dwFileSize, &dwFileSize, NULL);
		CloseHandle(hFile);
		HRESULT Res = in_pLinker->AddFragments(pFragments, dwFileSize);
		assert( Res == S_OK );
		HeapFree(GetProcessHeap(), 0, (void*)pFragments);
	}
}

void
CFeature_Textures::GetMyIDs( INVLink* in_pLinker ) {
	HRESULT Res;

	Res = in_pLinker->GetFragmentID("f_tex0_passthru", &(m_Fragment_Tex0_Passthru) );
	assert( Res == S_OK );
	Res = in_pLinker->GetFragmentID("f_tex1_passthru", &(m_Fragment_Tex1_Passthru) );
	assert( Res == S_OK );
}

void
CFeature_Textures::Reset() {
}

bool
CFeature_Textures::PreGenerate( CShaderResources& rRes, const CInputParams& rParams ) {
	// TODO: autogenerated textures
	return true;
}

std::list<NVLINK_FRAGMENT_ID>
CFeature_Textures::GetFragmentsForThisCombination( const CShaderResources& rRes, const CInputParams& rParams ) {
	m_Res = rRes;
	m_Params = rParams;
	
	std::list<NVLINK_FRAGMENT_ID> Frags;

	// TODO: autogenerated textures
	if(rParams.m_Tex0 != CInputParams::TT_NONE)
		Frags.push_back(m_Fragment_Tex0_Passthru);
	if(rParams.m_Tex1 != CInputParams::TT_NONE)
		Frags.push_back(m_Fragment_Tex1_Passthru);

	return Frags;
}

void
CFeature_Textures::GetConstants( INVLink* in_pLinker ) {
	// TODO: autogenerated textures
}

std::vector< std::pair<unsigned long,unsigned long> >
CFeature_Textures::GetBindings() const {
	// TODO: autogenerated textures
	return std::vector< std::pair<unsigned long,unsigned long> >();
}































